<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">
		<link rel="stylesheet" href="css/style.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<section>
					<h3>Programming principles</h3>
					<aside class="notes">
						Hello everyone! My today`s talk is about programming principles.
						Before start to explain these principles, let`s begin with such a question is programmer? 
					</aside>
				</section>

				<section>
					<h3>Who is programmer?</h3>
					<img src="./assets/1.jpeg" alt="">
					<aside class="notes">
						What does he do? Programmer - is someone who create code 
						So we may say that programmer is a person who coding.
						Really? Maybe he Programming? So what Is The Difference Between Coding & Programming?
					</aside>
				</section>

				<section>
					<img src="./assets/2.png" alt="">
					<aside class="notes">
						“Coding” and “Programming” are two most important approaches in Software Development Industries.
						Coding is basically the process of creating codes from one language to another one. 
						It can also be called as a subset of Programming since it actually implements the initial steps 
						of Programming. It involves writing codes in different languages as instructed. 
						While programming is the process of developing an executable machine level program 
						that can be implemented without any error.
						So, let us see the features in coding and programming.
					</aside>
				</section>
				
					<section>
						<h3>Comparison of Coding and Programming</h3>
						<table class="table1">
							<tr>
								<td>Definition</td>
								<td>Translation of natural language into machine commands through an intermediary coding language</td>
								<td>The process of development of fully functioning software solution</td>
							</tr>
							<tr>
								<td>Skills</td>
								<td>As a coder, you need to know the syntax of the programming language</td>
								<td>As a programmer, you need high-level thinking and analytical skills apart from coding skills. </td>
							</tr>
							<tr>
								<td>Tools</td>
								<td>A text editor would suffice</td>
								<td>Analysis tools, modeling programs, code generators, testing frameworks</td>
							</tr>
							<tr>
								<td>Outcome</td>
								<td>Simple solution or a small part of a project</td>
								<td>Full ready-to-use application</td>
							</tr>
						</table>
						<aside class="notes">
							The Difference between Coding and Programming are explained in the below-mentioned points:
							
							Definition:
							Coding is the process of translating and writing codes from one language to another 
							(to special machine commands). Programming is the process of building an executable program 
							(fully functional software solution).

							Skills:
							The machine can’t interact with human communications and it only understands the machine code
							which is the binary language. So, the main work of a coder is to translate the requirements 
							into machine understandable language using specific syntax of some language.
							Programmers use to analyze and conceptualize different aspects of any program and 
							also solutions to any problems that may or may not occur due to the process. 
							
							Tools:
							In the case of coding, one just has to deal with the codes and know some text editors or IDEs.
							On the other hand, programming includes some analysis tools, modeling programs, special frameworks
							for creating code and testing it.

							Outcome:
							Coding can be defined as a subset of the Programming approach 
							whereas Programming can be defined as a superset of Coding.
						</aside>
				</section>

				<section>
					<img src="./assets/programmingPrinciples.jpeg" alt="">
					<aside class="notes">
						So while studying some programming language it`s wise aim to become not just a coder, 
						but reach the highest point - programming.
						One of the way to do it - use some software design principles to improve code.
						Today I want to introduce you these principles. 
						I will explain some principles like: KISS, DRY, YANGI, SOLID, what each of them means, and 
						how to use it. Let`s begin.
					</aside>
				</section>

				<section>
					<h3>KISS</h3>
					<div>keep it short and simple</div>
					<img src="./assets/kiss.jpeg" alt="">
					<aside class="notes">
						Nobody in programming loves to debug, maintain or make changes in complex code. 
						KISS principle states that most systems work best if they are kept simple 
						rather than making it complex.
						So when you are writing code your solution should not be complicated that takes a lot of time 
						and effort to understand. If your code is simple then other developers won’t face any problem
						understanding the code logic. Always try to simplify your code using different approaches 
						like breaking a complex problem into smaller chunks or taking out some unnecessary code 
						you have written.
						As you can see in picture: if there is a simple way to solve a problem or 
						find a solution for some task, just do it. So KISS means keep it short and simple or 
						keep it simple and straightforward. 
						In the wise words of Antoine de Saint-Exupery, “Perfection is achieved, 
						not when there is nothing more to add, but when there is nothing left to take away.”
					</aside>
				</section>

				<section>
					<h3>DRY</h3>
					<div>don’t repeat yourself</div>
					<img src="./assets/dry.jpeg" alt="">
					<aside class="notes">
						Duplication of data, logic or function in code not only makes your code lengthy but 
						also wastes a lot of time when it comes to maintain, debug or modify the code. 
						If you need to make a small change in your code then you need to do it at several places. 
						“Don’t Repeat Yourself (DRY)” principle goal is to reduce the repetition of code. 
						It states that a piece of code should be implemented in just one place in the source code. 
						The opposite of the DRY principle is WET (“write everything twice” or “waste everyone’s time”) 
						which breaks the DRY principle if you are writing the same logic at several places. 
						You can create a common function or abstract your code to avoid the repetition in your code.

						The key points for how to apply abstraction to write code that doesn’t repeat itself:
						Create functions for common software patterns. We call them higher order functions.
    					Replace the boilerplate in your code with higher order functions.
						Some examples of higher order functions include:
    					map — modifying each element in the array based on a give rule
    					filter — getting a subset of the array that passes a given criterion
    					reduce — combining everything in the array based on a given rule

						Avoid repeating code. Sometimes you are going to need to use the same algorithm 
						in different places of your application, so instead of repeating the same lines of code 
						you must create a general solution in one entity or class and re-use it.
					</aside>
				</section>

				<section>
					<h3>YAGNI</h3>
					<div>You Aren’t Gonna Need It</div>
					<img src="./assets/yagni.png" alt="">
					<aside class="notes">
						Your software or program can become larger and complex if you are writing some code 
						which you may need in future but not at the moment. 
						“You Aren’t Gonna Need It (YAGNI)” principle states that “don’t implement something 
						until it is necessary” because in most of the cases you are not going to use that piece of code 
						in future. Most of the programmers while implementing software think about the future possibility 
						and add some code or logic for some other features which they don’t need at present. 
						They add all the unnecessary class and functionality which maybe they never use in the future. 
						Doing this is completely wrong. Don’t try to predict the future. 
						Just avoid this mistake, it helps to save a lot of time and effort.
					</aside>
				</section>

				<section>
					<section>
						<img src="./assets/solid.jpg" alt="">
						<aside class="notes">
							The SOLID principle is a coding standard in programming. 
							This principle is an acronym of the five principles which is given below…
							Single Responsibility Principle
							Open/Closed Principle
							Liskov’s Substitution Principle
							Interface Segregation Principle
							Dependency Inversion Principle
						</aside>
					</section>
					<section>
						<div>Single Responsibility Principle</div>
						<img src="./assets/SRP.jpg" alt="">
						<aside class="notes">
							Single Responsibility Principle: 
							Take the example of developing software first. 
							The task is divided into different members doing different things as front-end designers 
							do design, the tester does testing and backend developer takes care of backend development 
							part then we can say that everyone has a single job or responsibility.
							
							This principle states that “a class should have only one reason to change” 
							which means every class should have a single responsibility or single job or single purpose.
							Most of the time it happens that when programmers have to add features or new behavior 
							they implement everything into the existing class which is completely wrong. 
							It makes their code lengthy, complex and consumes time when later something needs 
							to be modified. Instead use layers in your application and break huge classes into 
							smaller classes or modules.
						</aside>
					</section>
					<section>
						<div>Open/Closed Principle</div>
						<img src="./assets/OCP.jpg" alt="">
						<aside class="notes">
							Open/Closed Principle: 
							This principle states that “software entities (classes, modules, 
							functions, etc.) should be open for extension, but closed for modification” which means 
							you should be able to extend a class behavior, without modifying it.
							Using this principle separates the existing code from the modified code so 
							it provides better stability, maintainability and minimizes changes in your code.
						</aside>
					</section>
					<section>
						<div>Liskov’s Substitution Principle</div>
						<img src="./assets/LSP.png" alt="">
						<aside class="notes">
							Liskov’s Substitution Principle: 
							According to this principle “Derived or child classes must be substitutable 
							for their base or parent classes“. This principle ensures that any class that 
							is the child of a parent class should be usable in place of its parent without any 
							unexpected behavior.

							You can understand it in a way that a some Car class can be a super class for 
							others cars classes like cabriolet, flashing cars, buggy and others by inheritance 
							of super class properties and basic logic. So it`s easy to even replace super class Car 
							by child classes. But it completely impossible to create Helicopter class as a child of Car class.
							Every subclass should be substitutable for their parent class.
						</aside>
					</section>
					<section>
						<div>Interface Segregation Principle</div>
						<img src="./assets/ISP.png" alt="">
						<aside class="notes">
							Interface Segregation Principle:
							This principle is the first principle that applies to Interfaces instead of classes in SOLID 
							and it is similar to the single responsibility principle. 
							It states: You should prefer many client interfaces rather than one general interface and 
							each interface should have a specific responsibility.

							Suppose if you enter a restaurant and you are pure vegetarian. 
							The waiter in that restaurant gave you the menu card which includes vegetarian items,
							non-vegetarian items, drinks, and sweets. In this case, as a customer, you should have 
							a menu card which includes only vegetarian items, not everything which you don’t eat 
							in your food. Here the menu should be different for different types of customers. 
							The common or general menu card for everyone can be divided into multiple cards 
							instead of just one. Using this principle helps in reducing the side effects and 
							frequency of required changes.
						</aside>
					</section>
					<section>
						<div>Dependency Inversion Principle</div>
						<img src="./assets/DIP.png" alt="">
						<aside class="notes">
							Dependency Inversion Principle: 
							This principle states: High-level modules/classes should not depend on 
							low-level modules/classes. 	Both should depend upon abstractions. 
							Abstractions should not depend upon details. Details should depend upon abstractions. 

							The above lines simply state that if a high module or class will be dependent 
							more on low-level modules or class then your code would have tight coupling and 
							if you will try to make a change in one class it can break another class 
							which is risky at the production level. So always try to make classes loosely coupled 
							as much as you can and you can achieve this through abstraction. 
							
							Entities must depend on abstractions not on concretions.
						</aside>
					</section>
				</section>

				<section> 
					<h3>Refactor Principle</h3>
					<img src="./assets/refactopPrinciple.jpg" alt="">
					<aside class="notes">
						This principle explains that the “code rarely comes out right the first time”. 
						With more advancements in the technologies, the coding has been developing with time. 
						Thus you need to keep in mind to remodify them with time. 
						As the new feature that you just implemented might be hindered by the complexity
						of the future feature. As you know that the Code is constantly evolving with the pass of time. 
						Therefore you need to rewrite and even sometimes redesign the whole chunk of code. 
						In addition to all this, the Refactor principle is a healthy process among 
						the Principles of Programming list. 
					</aside>
				</section>

				<section> 
					<h3>Thank you</h3>
					<img src="./assets/conclution1.png" alt="">
					<img src="./assets/conclution2.png" alt="">
					<img src="./assets/conclution3.png" alt="">
					<aside class="notes">
						In conclution I want to quote few interesting phrases:
						“Truth can only be found in one place: the code.”
						― Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship

						“Any fool can write code that a computer can understand. 
						Good programmers write code that humans can understand.” - Martin Fowler.

						“I'm not a great programmer; I'm just a good programmer with great habits.”
						― Kent Beck.
					</aside>
				</section>

			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				hash: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/highlight/highlight.js' },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>
	</body>
</html>
