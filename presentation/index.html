<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">
		<link rel="stylesheet" href="css/style.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<section>
					<h3>Who is programmer?</h3>
					<img src="./assets/1.jpeg" alt="">
					<aside class="notes">
						Hello everyone! My today`s talk is about programming principles.
						Before start to explain these principles, let`s begin our talk with some basics.
						Who is programmer? What does he do? 
						Programmer - is someone who create code. So we may say that programmer is a person who coding.
						Really? Maybe he Programming?
						What Is The Difference Between Coding & Programming?
					</aside>
				</section>

				<section>
					<img src="./assets/2.png" alt="">
					<aside class="notes">
						“Coding” and “Programming” are the two most important approaches in Software Development 
						Industries. Coding is basically the process of creating codes from one language to another one. 
						It can also be called as a subset of Programming since it actually implements the initial steps 
						of Programming. It involves writing codes in different languages as instructed. 
						Programming is the process of developing an executable machine level program that 
						can be implemented without any error. It is the process of formally writing codes 
						so that the human inputs and corresponding machine outputs remain in sync.
						So, let us see the features in coding and programming.
					</aside>
				</section>
				
					<section>
						<h3>Comparison of Coding and Programming</h3>
						<table class="table1">
							<tr>
								<td>Definition</td>
								<td>Translation of natural language into machine commands through an intermediary coding language</td>
								<td>The process of development of fully functioning software solution</td>
							</tr>
							<tr>
								<td>Skills</td>
								<td>As a coder, you need to know the syntax of the programming language</td>
								<td>As a programmer, you need high-level thinking and analytical skills apart from coding skills. </td>
							</tr>
							<tr>
								<td>Tools</td>
								<td>A text editor would suffice</td>
								<td>Analysis tools, modeling programs, code generators, testing frameworks</td>
							</tr>
							<tr>
								<td>Outcome</td>
								<td>Simple solution or a small part of a project</td>
								<td>Full ready-to-use application</td>
							</tr>
						</table>
						<aside class="notes">
							The Difference between Coding and Programming are explained in the below-mentioned points:
							Coding is the process of translating and writing codes from one language to another 
							whereas Programming is the process of building an executable program that can be used 
							to carry out proper machine level outputs.
							Coding only deals with the codes and so it is less intimidating and less intensive. 
							On the other hand, Programming deals with a program to control and interact with 
							the machine to produce proper results.
							Coders are mainly used to translate the requirements and their logic into a language 
							that machines can understand whereas Programming deals with much more than that. 
							It’s not only used to analyze and develop the codes but also engage all the different 
							artifacts to make the system perform in a proper way.
							Coding is the initial step of developing any software and thus it is much easier and simpler 
							to analyze and understand than Programming. Programming deals with different types of complex 
							scenarios and programs to ensure the proper implementation of the product.
							Coders only translate the requirement logics into a machine-understandable code without 
							worrying about the details. But on the other hand, Programmers use to analyze and 
							conceptualize different aspects of any program and also solutions to any problems 
							that may or may not occur due to the process. It works on a much broader aspect than coders.
							To become a programmer, different aspects of any approach needs to be considered. 
							In the case of coding, one just has to deal with the codes and concerned requirements. 
							So, complex programming requires a much more in-depth understanding of the language.
							Coding can be defined as a part of the Programming approach whereas Programming can be 
							defined as a superset of Coding. It deals with different aspects of any programming base 
							including the coding approach.
							The machine can’t interact with human communications and it only understands the machine code
							which is the binary language. So, the main work of a coder is to translate the requirements 
							into machine understandable language.
							Creating code is the beginning steps and then programming is used to analyze and implement 
							the same and produce the proper machine level output. It also involves all the critical 
							parameters from debugging and compiling to testing and implementation.
							Coders need to have a thorough understanding of the project working language. 
							However, they mainly code as per the project needs and instructed information. 
							This is the initial step of developing a software product. 
							Programmers use to analyze and conceptualize the different aspects of communication and 
							produce the correct machine outputs. It normally takes much more time for an individual 
							to become a programmer than a coder.
						</aside>
				</section>
				<section>
					
					<img src="./assets/programmingPrinciples.jpeg" alt="">
					<aside class="notes">
						Good programmer, of course, uses some software design principles to improve code.
						Today I want to introduce you these principles. 
						I will explain some principles like: KISS, DRY, YANGI, SOLID, what each of them means, and 
						how to use it. Let`s begin.
					</aside>
				</section>
				<section>
					<h3>KISS</h3>
					<div>keep it short and simple</div>
					<img src="./assets/kiss.jpeg" alt="">
					<aside class="notes">
						Nobody in programming love to debug, maintain or make changes in complex code. 
						“Keep It Simple, Stupid (KISS)“ states that most systems work best if they are kept simple 
						rather than making it complex, so when you are writing code your solution should not be 
						complicated that takes a lot of time and effort to understand. 
						If your code is simple then other developers won’t face any problem understanding 
						the code logic and they can easily proceed further with your code. 
						So always try to simplify your code using different approaches like breaking a complex problem 
						into smaller chunks or taking out some unnecessary code you have written.
						As you can see in picture: if there is a simple way to solve a problem or 
						find a solution for some task, just do it. So KISS means keep it short and simple or 
						keep it simple and straightforward. 
						In the wise words of Antoine de Saint-Exupery, “Perfection is achieved, 
						not when there is nothing more to add, but when there is nothing left to take away.”
					</aside>
				</section>
				<section>
					<h3>DRY</h3>
					<div>don’t repeat yourself</div>
					<img src="./assets/dry.jpeg" alt="">
					<aside class="notes">
						Duplication of data, logic or function in code not only makes your code lengthy but 
						also wastes a lot of time when it comes to maintain, debug or modify the code. 
						If you need to make a small change in your code then you need to do it at several places. 
						“Don’t Repeat Yourself (DRY)” principal goal is to reduce the repetition of code. 
						It states that a piece of code should be implemented in just one place in the source code. 
						The opposite of the DRY principle is WET (“write everything twice” or “waste everyone’s time”) 
						which breaks the DRY principle if you are writing the same logic at several places. 
						You can create a common function or abstract your code to avoid the repetition in your code.

						The key points for how to apply abstraction to write code that doesn’t repeat itself:
						Create functions for common software patterns. We call them higher order functions.
    					Replace the boilerplate in your code with higher order functions.
						Some examples of higher order functions include:
    					map — modifying each element in the array based on a give rule
    					filter — getting a subset of the array that passes a given criterion
    					reduce — combining everything in the array based on a given rule

						Avoid repeating code. Sometimes you are going to need to use the same algorithm 
						in different places of your application, so instead of repeating the same lines of code 
						you must create a general solution in one entity or class and re-use it.
					</aside>
				</section>
				<section>
					<h3>YAGNI</h3>
					<div>You Aren’t Gonna Need It</div>
					<img src="./assets/yagni.png" alt="">
					<aside class="notes">
						Your software or program can become larger and complex if you are writing some code 
						which you may need in future but not at the moment. 
						“You Aren’t Gonna Need It (YAGNI)” principle states that “don’t implement something 
						until it is necessary” because in most of the cases you are not going to use that piece of code 
						in future. Most of the programmers while implementing software think about the future possibility 
						and add some code or logic for some other features which they don’t need at present. 
						They add all the unnecessary class and functionality which maybe they never use in the future. 
						Doing this is completely wrong and you will eventually end up in writing bloated code 
						also your project becomes complicated and difficult to maintain. 
						We recommend all the programmers to avoid this mistake to save a lot of time and effort.

						Don’t try to predict the future. It is better to focus on the current functionality which 
						is being required and avoid programming methods which we suppose are gonna be needed 
						in the future , please don’t waste time on it.
					</aside>
				</section>
				<section>
					<section>
						<img src="./assets/solid.png" alt="">
						<aside class="notes">
							The SOLID principle was introduced by Robert C. Martin, also known as Uncle Bob 
							and it is a coding standard in programming. 
							This principle is an acronym of the five principles which is given below…
							Single Responsibility Principle (SRP)
							Open/Closed Principle
							Liskov’s Substitution Principle (LSP)
							Interface Segregation Principle (ISP)
							Dependency Inversion Principle (DIP)
						</aside>
					</section>
					<section>
						<div class="solid_S"></div>
						<aside class="notes">
							Single Responsibility Principle: This principle states that “a class should have only 
							one reason to change” which means every class should have a single responsibility or 
							single job or single purpose. Take the example of developing software. 
							The task is divided into different members doing different things as front-end designers 
							do design, the tester does testing and backend developer takes care of backend development 
							part then we can say that everyone has a single job or responsibility.
							Most of the time it happens that when programmers have to add features or new behavior 
							they implement everything into the existing class which is completely wrong. 
							It makes their code lengthy, complex and consumes time when later something needs 
							to be modified. Use layers in your application and break God classes into smaller classes 
							or modules.

							A class, Function or Entity should have only one reason to change, it means that if we need 
							to make changes on they, we must be sure that they are about the same function and 
							we are not creating new ones or combining responsibilities.
						</aside>
					</section>
					<section>
						<div class="solid_O"></div>
						<aside class="notes">
							Open/Closed Principle: This principle states that “software entities (classes, modules, 
							functions, etc.) should be open for extension, but closed for modification” which means 
							you should be able to extend a class behavior, without modifying it.
							Suppose developer A needs to release an update for a library or framework and 
							developer B wants some modification or add some feature on that then developer B 
							is allowed to extend the existing class created by developer A 
							but developer B is not supposed to modify the class directly. 
							Using this principle separates the existing code from the modified code so 
							it provides better stability, maintainability and minimizes changes as in your code.

							A software entity should be open for extension but closed for modification, 
							It means that we must be able to extend the behavior of one entity without having 
							to modify its code.
						</aside>
					</section>
					<section>
						<div class="solid_L"></div>
						<aside class="notes">
							Liskov’s Substitution Principle: The principle was introduced by Barbara Liskov in 1987 
							and according to this principle “Derived or child classes must be substitutable 
							for their base or parent classes“. This principle ensures that any class that 
							is the child of a parent class should be usable in place of its parent without any 
							unexpected behavior.
							You can understand it in a way that a farmer’s son should inherit farming skills from 
							his father and should be able to replace his father if needed. If the son wants to become 
							a farmer then he can replace his father but if he wants to become a cricketer then 
							definitely the son can’t replace his father even though they both belong to the same 
							family hierarchy. One of the classic examples of this principle is a rectangle having 
							four sides. A rectangle’s height can be any value and width can be any value. 
							A square is a rectangle with equal width and height. So we can say that we can extend 
							the properties of the rectangle class into square class. In order to do that 
							you need to swap the child (square) class with parent (rectangle) class to fit 
							the definition of a square having four equal sides but a derived class does not affect 
							the behavior of the parent class so if you will do that it will violate 
							the Liskov Substitution Principle. Check the link Liskov Substitution Principle 
							for better understanding.

							Every subclass should be substitutable for their parent class.
						</aside>
					</section>
					<section>
						<div class="solid_I"></div>
						<aside class="notes">
							Interface Segregation Principle: This principle is the first principle that applies 
							to Interfaces instead of classes in SOLID and it is similar to the single responsibility 
							principle. It states that “do not force any client to implement an interface 
							which is irrelevant to them“. Here your main goal is to focus on avoiding fat interface 
							and give preference to many small client-specific interfaces. 
							You should prefer many client interfaces rather than one general interface and 
							each interface should have a specific responsibility.
							Suppose if you enter a restaurant and you are pure vegetarian. 
							The waiter in that restaurant gave you the menu card which includes vegetarian items,
							non-vegetarian items, drinks, and sweets. In this case, as a customer, you should have 
							a menu card which includes only vegetarian items, not everything which you don’t eat 
							in your food. Here the menu should be different for different types of customers. 
							The common or general menu card for everyone can be divided into multiple cards 
							instead of just one. Using this principle helps in reducing the side effects and 
							frequency of required changes.

							It is better to have several client specific interfaces than a single general purpose 
							interface. In other words, a client should not be forced to implement an interface 
							that it doesn’t use or being forced to depend on methods which do not use.
						</aside>
					</section>
					<section>
						<div class="solid_D"></div>
						<aside class="notes">
							Dependency Inversion Principle: Before we discuss this topic keep in mind that 
							Dependency Inversion and Dependency Injection both are different concepts. 
							Most of the people get confused about it and consider both are the same. 
							Now two key points are here to keep in mind about this principle
							High-level modules/classes should not depend on low-level modules/classes. 
							Both should depend upon abstractions. Abstractions should not depend upon details. 
							Details should depend upon abstractions. 
							The above lines simply state that if a high module or class will be dependent 
							more on low-level modules or class then your code would have tight coupling and 
							if you will try to make a change in one class it can break another class 
							which is risky at the production level. So always try to make classes loosely coupled 
							as much as you can and you can achieve this through abstraction. 
							The main motive of this principle is decoupling the dependencies so if class A changes 
							the class B doesn’t need to care or know about the changes.
							You can consider the real-life example of a TV remote battery. 
							Your remote needs a battery but it’s not dependent on the battery brand. 
							You can use any XYZ brand that you want and it will work. 
							So we can say that the TV remote is loosely coupled with the brand name. 
							Dependency Inversion makes your code more reusable.

							Entities must depend on abstractions not on concretions. 
							It means that a class A must not depend on a specific class B, but on an abstraction.
						</aside>
					</section>
				</section>
				<section> 
					<h3>Refactor Principle</h3>

					<aside class="notes">
						Accept the hard truth about programming that you will not get to the full results 
						until you make the full coding for the project. Thus this principle explains that 
						the “code rarely comes out right the first time”. With more advancements in the technologies, 
						the coding has been developing with time. Thus you need to keep in mind to remodify them 
						with time. As the new feature that you just implemented might be hindered by the complexity
						of the future feature. As you know that the Code is constantly evolving with the pass of time. 
						Therefore you need to rewrite and even sometimes redesign the whole chunk of code. 
						In addition to all this, the Refactor principle is a healthy process among 
						the Principles of Programming list. 
					</aside>
				</section>

			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				hash: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/highlight/highlight.js' },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>
	</body>
</html>
